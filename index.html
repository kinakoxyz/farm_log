<script>
    // ▼▼▼ 設定エリア（自動化されたので削除しました） ▼▼▼
    
    // 全ターゲット定義（表示順序やカテゴリ分け用）
    const ALL_TARGETS = [
        "スプリンクラー", "天候", "いちご", "ブルーベリー", "りんご", "サボテン", "ぶどう", "すいか", 
        "ココナッツ", "マンゴー", "シュガーアップル", "スターフルーツ", "にんじん", "トマト", 
        "とうもろこし", "キノコ", "かぼちゃ", "豆の木", "イチジク", "トゲバンレイシ", "パパイヤ",
        // 以下、現在未使用でもリストにあれば表示可能
        "トゥースキノコ", "一つ目キノコ", "魔女キノコ", "コウモリキノコ", "トゥーストゲ花", 
        "トゥーススイセン", "鬼火キノコ", "悪霊すいか", "ネクタリン", "古代の果実", "絶叫カボチャ"
    ];

    // GistのベースURL (config.json と farm_log.txt を取得するため)
    // ユーザーIDとGistIDの部分まで
    const GIST_BASE = "https://gist.githubusercontent.com/kinakoxyz/9b9509f9f4a9139ad6196042de197560/raw/";
    
    let lastContent = "";
    let nextRefreshTime = null;
    let currentActiveTargets = []; // 自動同期されたリスト
    const noSleep = new NoSleep();

    // UI初期化：枠だけ作る
    function initUI() {
        const activeContainer = document.getElementById('active-list');
        const inactiveContainer = document.getElementById('inactive-list');
        activeContainer.innerHTML = '';
        inactiveContainer.innerHTML = '';
        // 読み込み中表示
        activeContainer.innerHTML = '<div style="color:#666; padding:10px;">SYNCING CONFIG...</div>';
    }

    // リスト描画更新関数
    function renderTargets() {
        const activeContainer = document.getElementById('active-list');
        const inactiveContainer = document.getElementById('inactive-list');
        
        activeContainer.innerHTML = '';
        inactiveContainer.innerHTML = '';

        ALL_TARGETS.forEach(item => {
            const isActive = currentActiveTargets.includes(item);
            const wrapper = document.createElement('label');
            wrapper.className = isActive ? 'target-item active-item' : 'target-item';
            
            // チェックボックス (表示用：操作してもボットには反映されませんが、見た目のために残します)
            wrapper.innerHTML = `<input type="checkbox" value="${item}" ${isActive ? 'checked' : 'disabled'}> ${item}`;
            
            if (isActive) {
                activeContainer.appendChild(wrapper);
            } else {
                inactiveContainer.appendChild(wrapper);
            }
        });
        
        // アクティブがない場合
        if(activeContainer.children.length === 0) {
            activeContainer.innerHTML = '<div style="color:#444; padding:10px;">NO ACTIVE TARGETS</div>';
        }
    }

    // ★設定同期: config.json を取得
    async function syncConfig() {
        try {
            const res = await fetch(GIST_BASE + "config.json?t=" + new Date().getTime());
            if (res.ok) {
                const data = await res.json();
                if (data.active && Array.isArray(data.active)) {
                    // 配列の中身が変わった時だけ再描画
                    if (JSON.stringify(data.active.sort()) !== JSON.stringify(currentActiveTargets.sort())) {
                        console.log("Config updated:", data.active);
                        currentActiveTargets = data.active;
                        renderTargets();
                    }
                }
            }
        } catch (e) {
            console.warn("Config sync failed (File might not verify yet):", e);
        }
    }

    // 各種スイッチの挙動
    document.getElementById('audio-switch').addEventListener('change', function() {
        const btn = document.getElementById('audio-btn');
        if(this.checked) { btn.classList.add('active'); playNotifySound(); }
        else { btn.classList.remove('active'); }
    });

    document.getElementById('nosleep-switch').addEventListener('change', function() {
        const btn = document.getElementById('nosleep-btn');
        if(this.checked) { noSleep.enable(); btn.classList.add('active'); }
        else { noSleep.disable(); btn.classList.remove('active'); }
    });

    // タイマー更新
    function updateTimers() {
        const now = new Date();
        document.getElementById('clock').innerText = now.toLocaleTimeString('ja-JP', {hour12:false});
        
        if (nextRefreshTime) {
            const totalSec = 300; 
            const diff = (nextRefreshTime - now) / 1000;
            const sec = Math.max(0, Math.floor(diff));
            
            document.getElementById('next-update-text').innerText = `NEXT UPDATE IN ${sec} SEC`;
            const pct = Math.min(100, (sec / 300) * 100); 
            document.getElementById('countdown-progress').style.width = `${pct}%`;

            if (diff <= 0) {
                nextRefreshTime = null;
                setTimeout(() => { 
                    fetchLog(); 
                    syncConfig(); // ログと一緒に設定も同期
                    calculateNextTime(); 
                }, 1500);
            }
        }
    }
    setInterval(updateTimers, 1000);

    function calculateNextTime() {
        const now = new Date();
        const min = now.getMinutes();
        let nextMin = (Math.floor(min / 5) * 5) + 6;
        const target = new Date();
        target.setMinutes(nextMin); target.setSeconds(0); target.setMilliseconds(0);
        nextRefreshTime = target;
    }

    // ログ取得処理
    async function fetchLog() {
        try {
            const response = await fetch(GIST_BASE + "farm_log.txt?t=" + new Date().getTime());
            const currentContent = await response.text();
            const audioOn = document.getElementById('audio-switch').checked;
            
            if (lastContent !== "" && currentContent !== lastContent) {
                const latestLine = currentContent.split('\n')[0];
                // 自動同期された currentActiveTargets を使って通知判定
                if (currentActiveTargets.some(t => latestLine.includes(t)) && audioOn) {
                    playNotifySound();
                }
            }
            document.getElementById('log-container').innerText = currentContent;
            lastContent = currentContent;
        } catch (e) { console.error(e); }
    }

    function playNotifySound() {
        const context = new (window.AudioContext || window.webkitAudioContext)();
        const gain = context.createGain();
        gain.connect(context.destination);
        const playTone = (freq, start, duration) => {
            const osc = context.createOscillator();
            osc.frequency.setValueAtTime(freq, context.currentTime + start);
            osc.type = 'square'; 
            osc.connect(gain);
            gain.gain.setValueAtTime(0.05, context.currentTime + start);
            osc.start(context.currentTime + start);
            osc.stop(context.currentTime + start + duration);
        };
        playTone(1200, 0, 0.08); 
        playTone(1800, 0.1, 0.15);
    }

    // 実行開始
    initUI();
    syncConfig(); // 初回設定同期
    fetchLog();
    calculateNextTime();
</script>
